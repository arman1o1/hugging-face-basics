# üîå Chapter 13: Model Context Protocol (MCP)

## üéØ Learning Objectives

In this notebook, you will learn:

1. **What is MCP**: Understanding the Model Context Protocol and why it was created
2. **MCP Architecture**: Client-server model and JSON-RPC communication
3. **Core Concepts**: Tools, Resources, Prompts, and how they work together
4. **Building MCP Servers**: Creating servers with FastMCP Python SDK
5. **Building MCP Clients**: Connecting to and interacting with MCP servers
6. **Practical Examples**: Real-world use cases and implementations

---

## üìñ Introduction

The **Model Context Protocol (MCP)** is an open standard introduced by Anthropic in November 2024 to standardize how Large Language Models (LLMs) integrate with external tools, systems, and data sources.

### The Problem MCP Solves

Before MCP, developers faced the **N√óM integration problem**:

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    WITHOUT MCP (N√óM Problem)                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                 ‚îÇ
‚îÇ   LLM 1 ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ Custom Connector ‚îÄ‚îÄ‚îÄ Tool A                       ‚îÇ
‚îÇ           ‚îú‚îÄ‚îÄ Custom Connector ‚îÄ‚îÄ‚îÄ Tool B                       ‚îÇ
‚îÇ           ‚îî‚îÄ‚îÄ Custom Connector ‚îÄ‚îÄ‚îÄ Tool C                       ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ   LLM 2 ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ Custom Connector ‚îÄ‚îÄ‚îÄ Tool A                       ‚îÇ
‚îÇ           ‚îú‚îÄ‚îÄ Custom Connector ‚îÄ‚îÄ‚îÄ Tool B                       ‚îÇ
‚îÇ           ‚îî‚îÄ‚îÄ Custom Connector ‚îÄ‚îÄ‚îÄ Tool C                       ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ   ‚ö†Ô∏è Each LLM needs custom code for EACH tool = N √ó M work!    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      WITH MCP (N+M Solution)                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                 ‚îÇ
‚îÇ   LLM 1 ‚îÄ‚îÄ‚îê                       ‚îå‚îÄ‚îÄ Tool A                    ‚îÇ
‚îÇ           ‚îÇ                       ‚îÇ                             ‚îÇ
‚îÇ   LLM 2 ‚îÄ‚îÄ‚îº‚îÄ‚îÄ MCP Protocol ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ Tool B                    ‚îÇ
‚îÇ           ‚îÇ                       ‚îÇ                             ‚îÇ
‚îÇ   LLM 3 ‚îÄ‚îÄ‚îò                       ‚îî‚îÄ‚îÄ Tool C                    ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ   ‚úÖ Universal protocol = N + M implementations only!          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

> üí° **Key Insight**: MCP provides a "USB-C for AI" - a universal connector that any LLM can use to interact with any tool or data source.

---

## üîß Part 1: Environment Setup

### Installing Required Packages

| Package   | Purpose                                      |
|-----------|----------------------------------------------|
| `mcp`     | Official MCP Python SDK (includes FastMCP)   |
| `httpx`   | Async HTTP client for API calls              |
| `pydantic`| Data validation and settings                 |

> üí° **Note**: FastMCP is now **built into** the `mcp` package at `mcp.server.fastmcp`. No separate installation needed!

```bash
# Install required packages
pip install mcp httpx pydantic
```

```python
# Import required modules
import json
import asyncio
from typing import Any, Optional
from datetime import datetime

print("‚úÖ Basic modules imported successfully!")
```

---

## üß© Part 2: Core MCP Concepts

MCP defines several building blocks that servers can expose:

### 1. Tools üîß

**Executable functions** that LLMs can call to perform actions or retrieve information.

```python
# Example Tool Definition
{
    "name": "calculate_bmi",
    "description": "Calculate Body Mass Index from height and weight",
    "inputSchema": {
        "type": "object",
        "properties": {
            "height_cm": {"type": "number", "description": "Height in centimeters"},
            "weight_kg": {"type": "number", "description": "Weight in kilograms"}
        },
        "required": ["height_cm", "weight_kg"]
    }
}
```

### 2. Resources üì¶

**Structured data** that can be included in the LLM's prompt context (files, database records, API responses).

```python
# Example Resource
{
    "uri": "file:///config/settings.json",
    "name": "Application Settings",
    "mimeType": "application/json"
}
```

### 3. Prompts üìù

**Reusable templates** that add context or instructions for the LLM.

```python
# Example Prompt
{
    "name": "code_review",
    "description": "Review code for bugs and improvements",
    "arguments": [
        {"name": "language", "required": True},
        {"name": "code", "required": True}
    ]
}
```

### 4. Roots üìÅ

**Entry points** into filesystems, providing servers access to specific directories.

### 5. Sampling üé≤

Allows servers to **request LLM completions** from clients, enabling complex agentic workflows.

---

## üöÄ Part 3: Building MCP Servers with FastMCP

FastMCP provides a **simplified, decorator-based** approach to building MCP servers.

### Calculator Server (FastMCP)

```python
# calculator_server_fastmcp.py
from mcp.server.fastmcp import FastMCP
import math

# Create a FastMCP server instance
# json_response=True returns JSON instead of SSE streaming (recommended for most cases)
mcp = FastMCP("Calculator Server", json_response=True)

# Define tools using simple decorators - type hints auto-generate inputSchema!
@mcp.tool()
def add(a: float, b: float) -> float:
    """Add two numbers together."""
    return a + b

@mcp.tool()
def multiply(a: float, b: float) -> float:
    """Multiply two numbers."""
    return a * b

@mcp.tool()
def sqrt(n: float) -> float:
    """Calculate square root of a number."""
    if n < 0:
        raise ValueError("Cannot calculate square root of negative number")
    return math.sqrt(n)

# Run the server (defaults to stdio transport)
if __name__ == "__main__":
    mcp.run()
```

### Weather Server (FastMCP)

```python
# weather_server_fastmcp.py
from mcp.server.fastmcp import FastMCP
import json

mcp = FastMCP("Weather Service")

# Mock weather data
WEATHER_DATA = {
    "new york": {"temp": 18, "condition": "Cloudy", "humidity": 65},
    "london": {"temp": 12, "condition": "Rainy", "humidity": 80},
    "tokyo": {"temp": 22, "condition": "Sunny", "humidity": 55},
    "sydney": {"temp": 28, "condition": "Clear", "humidity": 45},
    "mumbai": {"temp": 32, "condition": "Humid", "humidity": 75},
    "paris": {"temp": 15, "condition": "Partly Cloudy", "humidity": 60}
}

# ============== TOOLS ==============
@mcp.tool()
def get_weather(city: str) -> str:
    """Get current weather for a city."""
    city_lower = city.lower()
    if city_lower in WEATHER_DATA:
        data = WEATHER_DATA[city_lower]
        return f"""Weather in {city.title()}:
  üå°Ô∏è Temperature: {data["temp"]}¬∞C
  ‚òÅÔ∏è Condition: {data["condition"]}
  üíß Humidity: {data["humidity"]}%"""
    return f"Weather data not available for {city}"

@mcp.tool()
def compare_weather(city1: str, city2: str) -> str:
    """Compare weather between two cities."""
    c1, c2 = city1.lower(), city2.lower()
    if c1 not in WEATHER_DATA or c2 not in WEATHER_DATA:
        return "One or both cities not found"
    d1, d2 = WEATHER_DATA[c1], WEATHER_DATA[c2]
    diff = abs(d1["temp"] - d2["temp"])
    return f"""Weather Comparison:
{city1.title()}: {d1["temp"]}¬∞C ({d1["condition"]})
{city2.title()}: {d2["temp"]}¬∞C ({d2["condition"]})
Temperature difference: {diff}¬∞C"""

# ============== RESOURCES ==============
@mcp.resource("weather://cities")
def get_cities() -> str:
    """List of cities with weather data."""
    cities = [c.title() for c in WEATHER_DATA.keys()]
    return json.dumps({"available_cities": cities})

# ============== PROMPTS ==============
@mcp.prompt()
def travel_advisory(destination: str) -> str:
    """Get travel weather advisory for a destination."""
    return f"Please provide a travel weather advisory for {destination}. Include packing recommendations based on current weather."

if __name__ == "__main__":
    mcp.run()
```

### Filesystem Server (FastMCP)

```python
# filesystem_server_fastmcp.py
from mcp.server.fastmcp import FastMCP
from pathlib import Path

mcp = FastMCP("Filesystem Server")

# Define a safe base directory
BASE_DIR = Path("./workspace")
BASE_DIR.mkdir(exist_ok=True)

def safe_path(filename: str) -> Path:
    """Ensure path stays within BASE_DIR."""
    path = (BASE_DIR / filename).resolve()
    if not str(path).startswith(str(BASE_DIR.resolve())):
        raise ValueError("Access denied: path outside workspace")
    return path

@mcp.tool()
def list_files(subdir: str = ".") -> str:
    """List files in workspace directory."""
    try:
        path = safe_path(subdir)
        if not path.exists():
            return "Directory not found"
        files = [f.name for f in path.iterdir()]
        if not files:
            return "Directory is empty"
        return f"Files in {subdir}:\n" + "\n".join(f"  ‚Ä¢ {f}" for f in files)
    except ValueError as e:
        return str(e)

@mcp.tool()
def read_file(filename: str) -> str:
    """Read contents of a file."""
    try:
        path = safe_path(filename)
        if not path.exists():
            return "File not found"
        return f"Content of {filename}:\n{path.read_text()}"
    except ValueError as e:
        return str(e)

@mcp.tool()
def write_file(filename: str, content: str) -> str:
    """Write content to a file."""
    try:
        path = safe_path(filename)
        path.write_text(content)
        return f"Successfully wrote to {filename}"
    except ValueError as e:
        return str(e)

if __name__ == "__main__":
    mcp.run()
```

---

## üèóÔ∏è Part 4: Low-Level Server API

For more control, you can use the low-level Server API:

### Calculator Server (Low-Level)

```python
# calculator_server_lowlevel.py
from mcp.server import Server
from mcp.types import Tool, TextContent
import mcp.server.stdio
import asyncio
import math

# Create an MCP server instance
server = Server("calculator-server")

# Define available tools
@server.list_tools()
async def list_tools():
    """Return list of available calculator tools."""
    return [
        Tool(
            name="add",
            description="Add two numbers together",
            inputSchema={
                "type": "object",
                "properties": {
                    "a": {"type": "number", "description": "First number"},
                    "b": {"type": "number", "description": "Second number"}
                },
                "required": ["a", "b"]
            }
        ),
        Tool(
            name="multiply",
            description="Multiply two numbers",
            inputSchema={
                "type": "object",
                "properties": {
                    "a": {"type": "number", "description": "First number"},
                    "b": {"type": "number", "description": "Second number"}
                },
                "required": ["a", "b"]
            }
        ),
        Tool(
            name="sqrt",
            description="Calculate square root of a number",
            inputSchema={
                "type": "object",
                "properties": {
                    "n": {"type": "number", "description": "Number to find square root of"}
                },
                "required": ["n"]
            }
        )
    ]

# Handle tool calls
@server.call_tool()
async def call_tool(name: str, arguments: dict):
    """Execute a calculator tool."""
    if name == "add":
        result = arguments["a"] + arguments["b"]
        return [TextContent(type="text", text=f"Result: {result}")]
    
    elif name == "multiply":
        result = arguments["a"] * arguments["b"]
        return [TextContent(type="text", text=f"Result: {result}")]
    
    elif name == "sqrt":
        if arguments["n"] < 0:
            return [TextContent(type="text", text="Error: Cannot calculate square root of negative number")]
        result = math.sqrt(arguments["n"])
        return [TextContent(type="text", text=f"Result: {result}")]
    
    else:
        return [TextContent(type="text", text=f"Unknown tool: {name}")]

# Run the server
async def main():
    async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
        await server.run(
            read_stream,
            write_stream,
            server.create_initialization_options()
        )

if __name__ == "__main__":
    asyncio.run(main())
```

---

## üåê Part 5: Transport Options

MCP supports multiple transport mechanisms for client-server communication:

### Stdio Transport (Default)

Uses standard input/output streams for direct process communication between local processes.

```python
# Default stdio transport
if __name__ == "__main__":
    mcp.run()  # or mcp.run(transport="stdio")
```

### Streamable HTTP Transport

Uses HTTP POST with optional Server-Sent Events for streaming. Ideal for remote deployments.

```python
from mcp.server.fastmcp import FastMCP

mcp = FastMCP("My HTTP Server", json_response=True)

@mcp.tool()
def hello(name: str) -> str:
    return f"Hello, {name}!"

if __name__ == "__main__":
    # Run with HTTP transport
    mcp.run(transport="streamable-http")
    # Server accessible at http://localhost:8000/mcp
```

### Stateless HTTP (Production)

For production deployments, use stateless mode for better scalability:

```python
from mcp.server.fastmcp import FastMCP

# Stateless server with JSON responses (recommended for production)
mcp = FastMCP("StatelessServer", stateless_http=True, json_response=True)

@mcp.tool()
def greet(name: str = "World") -> str:
    """Greet someone by name."""
    return f"Hello, {name}!"

if __name__ == "__main__":
    mcp.run(transport="streamable-http")
```

| Transport           | Use Case                         | Command                                    |
|---------------------|----------------------------------|--------------------------------------------|
| `stdio` (default)   | Local CLI tools, Claude Desktop  | `mcp.run()`                                |
| `streamable-http`   | Web servers, remote access       | `mcp.run(transport="streamable-http")`     |
| `sse`               | Legacy SSE streaming             | `mcp.run(transport="sse")`                 |

---

## üîå Part 6: Building MCP Clients

### Client Example

```python
# calculator_client.py
import asyncio
from mcp.client.session import ClientSession
from mcp.client.stdio import StdioServerParameters, stdio_client

async def run_client():
    """Connect to the calculator server and call tools."""
    
    # Define server parameters
    server_params = StdioServerParameters(
        command="python",
        args=["calculator_server_fastmcp.py"]
    )
    
    async with stdio_client(server_params) as (read, write):
        async with ClientSession(read, write) as session:
            # Initialize the connection
            await session.initialize()
            
            # List available tools
            tools = await session.list_tools()
            print("üìã Available Tools:")
            for tool in tools.tools:
                print(f"   ‚Ä¢ {tool.name}: {tool.description}")
            
            print("\n" + "="*50 + "\n")
            
            # Call the add tool
            print("üîß Calling add(5, 3):")
            result = await session.call_tool("add", {"a": 5, "b": 3})
            print(f"   {result.content[0].text}")
            
            # Call the multiply tool
            print("\nüîß Calling multiply(7, 8):")
            result = await session.call_tool("multiply", {"a": 7, "b": 8})
            print(f"   {result.content[0].text}")
            
            # Call the sqrt tool
            print("\nüîß Calling sqrt(144):")
            result = await session.call_tool("sqrt", {"n": 144})
            print(f"   {result.content[0].text}")

if __name__ == "__main__":
    asyncio.run(run_client())
```

### HTTP Client Example

```python
# http_client.py
import asyncio
from mcp.client.session import ClientSession
from mcp.client.streamable_http import streamablehttp_client

async def main():
    # Connect to a streamable HTTP server
    async with streamablehttp_client("http://localhost:8000/mcp") as (
        read_stream,
        write_stream,
        _,
    ):
        async with ClientSession(read_stream, write_stream) as session:
            await session.initialize()
            tools = await session.list_tools()
            print(f"Available tools: {[tool.name for tool in tools.tools]}")

if __name__ == "__main__":
    asyncio.run(main())
```

---

## ü§ñ Part 7: MCP with LLMs - Agentic Workflows

The true power of MCP comes from integrating it with LLMs to create agentic workflows.

### How LLMs Use MCP Tools

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Agentic Workflow with MCP                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                 ‚îÇ
‚îÇ  User: "What's the weather in Tokyo and should I pack           ‚îÇ
‚îÇ         an umbrella?"                                           ‚îÇ
‚îÇ                    ‚Üì                                            ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ                        LLM                               ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  1. Understands user wants weather info                  ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  2. Sees available MCP tools                             ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  3. Calls: get_weather(city="tokyo")                     ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                       ‚Üì                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ              MCP Server (Weather)                        ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  Returns: {temp: 22, condition: "Sunny", humidity: 55}   ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                       ‚Üì                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ                        LLM                               ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  Generates response using tool result:                   ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  "Tokyo is currently 22¬∞C and Sunny. No umbrella needed!"‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Mock Tool Handler Example

```python
from datetime import datetime
import ast

class MockMCPToolHandler:
    """Simulates MCP tool availability for an LLM."""
    
    def __init__(self):
        self.tools = {
            "get_weather": self._get_weather,
            "calculate": self._calculate,
            "get_time": self._get_time
        }
    
    def list_tools(self):
        """Return available tools (would come from MCP server)."""
        return [
            {"name": "get_weather", "description": "Get weather for a city"},
            {"name": "calculate", "description": "Perform math calculations"},
            {"name": "get_time", "description": "Get current time for timezone"}
        ]
    
    def call_tool(self, name: str, args: dict) -> str:
        """Call a tool and return result."""
        if name in self.tools:
            return self.tools[name](args)
        return f"Tool '{name}' not found"
    
    def _get_weather(self, args):
        city = args.get("city", "unknown")
        return f"Weather in {city}: 22¬∞C, Partly Cloudy"
    
    def _calculate(self, args):
        expr = args.get("expression", "0")
        try:
            # Use ast.literal_eval for safety instead of eval()
            # For complex expressions, consider using a math parser library
            result = ast.literal_eval(expr) if expr.isdigit() else eval(expr)
            return f"Result: {result}"
        except Exception:
            return "Calculation error"
    
    def _get_time(self, args):
        return f"Current time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"

# Demonstrate usage
handler = MockMCPToolHandler()

print("üìã Available MCP Tools:")
for tool in handler.list_tools():
    print(f"   ‚Ä¢ {tool['name']}: {tool['description']}")

print("\n" + "="*50 + "\n")
print("üîß Simulating LLM Tool Calls:\n")

# Simulate tool calls that an LLM might make
calls = [
    ("get_weather", {"city": "Berlin"}),
    ("calculate", {"expression": "15 * 23 + 7"}),
    ("get_time", {})
]

for tool_name, args in calls:
    result = handler.call_tool(tool_name, args)
    print(f"Tool: {tool_name}({args})")
    print(f"Result: {result}\n")
```

> ‚ö†Ô∏è **Security Note**: The `eval()` function is dangerous in production. Consider using `ast.literal_eval()` for simple expressions or a safe math parsing library like `simpleeval` for more complex calculations.

---

## üîê Part 8: Best Practices and Security

When building MCP servers, follow these important guidelines:

### Security Best Practices

| Practice             | Description                                            |
|----------------------|--------------------------------------------------------|
| **Input Validation** | Always validate and sanitize inputs from tools         |
| **Sandboxing**       | Restrict file system access to specific directories    |
| **Rate Limiting**    | Implement rate limits for tool calls                   |
| **Logging**          | Log all tool invocations for audit purposes            |
| **Least Privilege**  | Only expose necessary capabilities                     |

### Design Patterns

```python
# Pattern 1: Tool with validation
@server.call_tool()
async def call_tool(name: str, arguments: dict):
    # Validate input before processing
    if not validate_input(arguments):
        return [TextContent(type="text", text="Invalid input")]
    
    # Process with error handling
    try:
        result = await process_tool(name, arguments)
        return [TextContent(type="text", text=result)]
    except Exception as e:
        log_error(e)
        return [TextContent(type="text", text="An error occurred")]

# Pattern 2: Resource with caching
from functools import lru_cache

@lru_cache(maxsize=100)
def get_cached_resource(uri: str):
    return fetch_expensive_resource(uri)
```

---

## üìä Part 9: Configuring MCP with Claude Desktop

To use your MCP servers with Claude Desktop, you need to configure the `claude_desktop_config.json` file.

### Configuration Location

| OS      | Path                                                              |
|---------|-------------------------------------------------------------------|
| macOS   | `~/Library/Application Support/Claude/claude_desktop_config.json` |
| Windows | `%APPDATA%\Claude\claude_desktop_config.json`                     |

### Example Configuration

```json
{
  "mcpServers": {
    "calculator": {
      "command": "python",
      "args": [
        "C:/path/to/calculator_server_fastmcp.py"
      ]
    },
    "weather": {
      "command": "python",
      "args": [
        "C:/path/to/weather_server_fastmcp.py"
      ]
    },
    "filesystem": {
      "command": "python",
      "args": [
        "C:/path/to/filesystem_server_fastmcp.py"
      ]
    },
    "github": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-github"
      ],
      "env": {
        "GITHUB_PERSONAL_ACCESS_TOKEN": "your-token-here"
      }
    }
  }
}
```

üí° **Tips**:

1. Use absolute paths for your servers
2. Restart Claude Desktop after changing config
3. Check server logs if tools don't appear

---

## üìö Part 10: Pre-built MCP Servers

Anthropic and the community have created many ready-to-use MCP servers:

| Server           | Purpose               | Install Command                               |
|------------------|-----------------------|-----------------------------------------------|
| **GitHub**       | Repository management | `npx @modelcontextprotocol/server-github`     |
| **Filesystem**   | File operations       | `npx @modelcontextprotocol/server-filesystem` |
| **PostgreSQL**   | Database queries      | `npx @modelcontextprotocol/server-postgres`   |
| **Slack**        | Messaging             | `npx @modelcontextprotocol/server-slack`      |
| **Google Drive** | Document access       | `npx @modelcontextprotocol/server-gdrive`     |

> üîó **Resources**:
>
> - Official MCP Documentation: <https://modelcontextprotocol.io>
> - MCP GitHub Repository: <https://github.com/modelcontextprotocol>
> - Python SDK: <https://github.com/modelcontextprotocol/python-sdk>

---

## üìã Quick Reference: MCP Server Template

### FastMCP (Recommended)

```python
from mcp.server.fastmcp import FastMCP

mcp = FastMCP("my-server")

@mcp.tool()
def my_tool(param: str) -> str:
    """Description here."""
    return f"Processed: {param}"

if __name__ == "__main__":
    mcp.run()
```

### Low-Level API

```python
from mcp.server import Server
from mcp.types import Tool, TextContent
import mcp.server.stdio
import asyncio

server = Server("my-server")

@server.list_tools()
async def list_tools():
    return [
        Tool(
            name="my_tool",
            description="Description here",
            inputSchema={
                "type": "object",
                "properties": {
                    "param": {"type": "string"}
                },
                "required": ["param"]
            }
        )
    ]

@server.call_tool()
async def call_tool(name: str, arguments: dict):
    if name == "my_tool":
        result = f"Processed: {arguments['param']}"
        return [TextContent(type="text", text=result)]

async def main():
    async with mcp.server.stdio.stdio_server() as (r, w):
        await server.run(r, w, server.create_initialization_options())

if __name__ == "__main__":
    asyncio.run(main())
```

---

## üéØ Summary

| Concept        | Description                                   |
|----------------|-----------------------------------------------|
| **MCP**        | Universal protocol for LLM-tool integration   |
| **Tools**      | Executable functions LLMs can call            |
| **Resources**  | Data sources for context                      |
| **Prompts**    | Reusable instruction templates                |
| **FastMCP**    | Simplified decorator-based server SDK         |
| **Transports** | stdio (local) or streamable-http (web)        |
